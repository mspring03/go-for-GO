// 그리디란 어떤 문제가 있을 때 단순 무식하게, 탐욕적으로 문제를 푸는 알고리즘이다.
// 탐욕적 -> 현재 상황에서 지금 당장 좋은 것만 고르는 방법
// 순간 순간마다의 최선의 결정이 전체 문제에서 최선의 해결책이 되지 않는다.
// 매 순간 최적인 경우만 찾아가기 때문에 DP보다 빠른 속도로 빠르게 결과를 얻을 수 있다.
// 하지만, ‘최적 부분 구조’와 '탐욕스런 선택 조건’이 만족해야 사용할 수 있음.
//	 최적 부분 구조 -> 문제에 대한 최종 해결 방법이 부분 문제에 대해서도 해결 방법이다.
// 	 탐욕스런 선택 조건 -> 앞의 선택이 이후의 선택에 영향을 주지 않는다.

// 그리디 방식을 왜 사용하는걸까?
//   -> 아무리 DP를 통해 Memorizing을 하더라도, 그리디는 최선의 경우만 생각하기 때문에 빠름

package main

import (
	"fmt"
)

func main() {
	var n, cnt = 3650, 0

	// 큰 단위의 화폐부터 차례대로 확인
	coins := []int{500, 100, 50, 10}

	for _, coin := range coins {
		// 해당 화폐로 거슬러 줄 수 있는 동전의 개수 세기
		cnt += n/coin

		// 해당 화폐로 최대한 거슬러 주었을 때 남은 거스름돈
		n %= coin
	}

	fmt.Println(cnt)
}
